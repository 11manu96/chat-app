\documentclass[letterpaper, 11pt]{article}
\usepackage[letterpaper, margin=1.4in]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{verbatimbox}
\usepackage{listings}
\lstset{
 basicstyle=\ttfamily,
 columns=fullflexible,
 frame=single,
 breaklines=true,
}
\usepackage{caption}
\usepackage{subcaption}

\title{ChatApp Design API Specification}
\author{Team Houston\\ Jonathan Wang, Manu Maheshwari, Yanjun Yang,\\ Tianqi Ma, Youyi Wei, Jiang Lin, Chengyin Liu}
\date{}

\setlength\parindent{0pt}

\begin{document}
\maketitle

We used command pattern, composite pattern and singleton pattern in this chat app. We have two controllers ChatAppController and WebSocketController to handle the requests and communications. All the objects use commands to act in the chat app.\\

In this document, we will discuss the use cases for the chat app. Then we will break down the interfaces and abstract classes in the model. 

\section{Use Cases}
\begin{itemize}
\item Open ChatApp
\begin{itemize}
\item Return internal user id counter to view
\item Start in login screen: create new user or map session to existing username/user
\end{itemize}
\item Create ChatRoom
\begin{itemize}
\item POST(restrictions, username)
\item ChatAppController: create chat room, add room to observers, add user to room
\end{itemize}
\item Join ChatRoom
\begin{itemize}
\item Select room to join from list of rooms user can join
\item POST(user, room to join) 
\item ChatAppController: add user as observer of room, add room to user list
\end{itemize}
\item Leave ChatRoom
\begin{itemize}
\item User can choose to leave the ChatRoom.
\item POST(user, room to leave)
\item ChatAppController: delete user from the room, remove room from the user list
\end{itemize}
\item Send message
\begin{itemize}
\item Select user(s) in chat room to send message to, type message
\item Websocket sends JSON(sender, recipient, chat room, message)
\item WebSocketController: onMessage - use commands, notify observer to send message to recipient
\end{itemize}
\item Check ChatRooms User is in/can join, Users in ChatRoom
\end{itemize}

\section{View}
We have a login screen, a chat room list, chat room, create chat room and buttons for send message, join/leave chat room etc. in the view.

\section{Controller}
We have two controllers: ChatAppController and WebSocketController. 
\begin{itemize}
\item ChatAppController is an observable observed by chat rooms, and singleton pattern is also implemented here. WebSocketController will call the ChatAppController instance to communicate. It has three fields and eleven methods:
\begin{itemize}
\item sessionUsernameHashmap: a ConcurrentHashMap maps the session and username.
\item usernameUserHashmap: a ConcurrentHashMap maps the username and user object.
\item chatAppController: an instance of itself.
\item ChatAppController(): constructor.
\item getInstance(): get singleton instance of ChatAppController.
\item main(String[] args): ChatApp entry point.
\item logIn(Session user, String request): creates a new user if user not created or retrieves an existing user.
\item getEligibleChatRooms(Session user, String request): get all chatrooms user is in or can join. Send as JSON to session.
\item createChatRoom(Session user, String request): create a chat room. Send updated lists as JSON to session.
\item joinChatRoom(Session user, String request): join a chat room. Send updated lists as JSON to session.
\item getChatRoom(Session user, String request): get users in chat room and chat history. Send as JSON to session.
\item leaveChatRoom(Session user, String request): exit one or all chat rooms. Send updated lists as JSON to session.
\item sendMessage(String request): send a message command to all the chat room observers.
\item getHerokuAssignedPort(): get the heroku assigned port number.
\end{itemize}

\item WebSocketController creates a web socket for the server, it also manages all the end points. We have seven end points:
\begin{itemize}
\item ``log$\_$in": create or retrieve user in hash map.
\item ``get$\_$eligible$\_$chat$\_$rooms": get list of chat rooms that user is in or can join.
\item ``join$\_$chat$\_$room": join an existing chat room.
\item ``get$\_$chat$\_$room": get users in chat room and message history when entering chat room.
\item ``exit$\_$chat$\_$room": exit one or all chat rooms.
\item ``create$\_$chat$\_$room": create chat room.
\item ``send$\_$message": send message to user in chat room.
\end{itemize}
\end{itemize}

We have an import design decision here: All requests from view go to WebSocketController via websocket send interface. ChatAppController handles backend actions and sends response back to view as a message, which allows us to use Session as the single identifier from the view. 

\section{Model}
\subsection{Command}
We have one interface for the commands: ISndMsgCmd. This command will be executed by the user and chat room. It has one function: execute(Object context), which 
executes the command by the receiver (context). We will have UserSendMsgCmd etc implement this interface. ChatAppController uses command to update chat rooms. 

\subsection{Objects}
We have two concrete objects: ChatRoom and User. They are all observer/observables. 
\begin{itemize}
\item ChatRoom represents a chat room in the ChatApp. It observes the ChatAppController and is observed by the users in the chat room. It has five fields and twelve methods:

\item User represents a ChatApp user that can exist across sessions. The User observes each chat room it is in. It has five fields and twelve methods:

\item Composite User and composite ChatRoom inherit User and ChatRoom respectively. We use composite User for sending messages to multiple users and composite ChatRoom for user to exit all chat rooms. 

\end{itemize}

\end{document}